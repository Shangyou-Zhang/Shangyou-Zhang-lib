### 1. **浮点数基本类型**

- **`float`**：单精度浮点数，占用 **4字节**（32位），有效数字精度大约为 **6-7位**。
- **`double`**：双精度浮点数，占用 **8字节**（64位），有效数字精度大约为 **15-16位**。
- **`long double`**：扩展精度浮点数，占用字节数依赖于平台，通常为 **10或12字节**，精度比 `double` 更高。

示例：

```c
float f = 3.14f;    // 单精度浮点数
double d = 3.14159; // 双精度浮点数
long double ld = 3.141592653589793; // 扩展精度浮点数
```

### 2. **浮点数的表示**

- 浮点数通常采用 **科学计数法** 表示，即形式为 `a * 10^b`。例如 `3.14` 或 `1.23e4`（表示 `1.23 * 10^4`）。
- 浮点数按 **IEEE 754** 标准表示，包含三个部分：
    - **符号位**（1位）：表示浮点数的正负。
    - **指数位**（8位，单精度；11位，双精度）：表示浮点数的指数。
    - **尾数位**（23位，单精度；52位，双精度）：表示浮点数的小数部分（有效数字）。

### 3. **浮点常量**

- 默认情况下，浮点常量是 **`double` 类型**，例如 `3.14`。
- 若要表示 **`float` 类型** 常量，必须加上后缀 **`f`**，例如 `3.14f`。
- **科学计数法**：如 `1.23e4` 表示 `1.23 * 10^4`，可以表示非常大或非常小的浮点数。

示例：

```c
float a = 3.14f;    // 浮点数常量 f，表示单精度
double b = 3.14159; // 浮点数常量，默认是双精度
double c = 1.23e4;  // 使用科学计数法
```

### 4. **浮点数的运算**

- 浮点数支持加、减、乘、除四则运算，但由于其精度有限，可能产生舍入误差。
- 浮点数的除法，如果除数为零，结果是无穷大 (`+∞` 或 `-∞`)，或 `NaN`（不是一个数字）。

示例：

```c
float a = 5.0f, b = 2.0f;
float sum = a + b;       // 加法
float diff = a - b;      // 减法
float prod = a * b;      // 乘法
float quotient = a / b;  // 除法
```

### 5. **浮点数的精度问题**

- 由于浮点数是有限精度表示的，可能会导致精度丢失。例如，`0.1 + 0.2` 在计算机中可能不等于 `0.3`。
- **浮点数的舍入误差**：浮点数的表示不能精确表达所有实数，尤其是一些常见的小数（如 `0.1`）在计算机中不能精确表示。
- 为了避免浮点数的比较误差，使用 **误差容忍（epsilon）** 方法来判断两个浮点数是否相等。

示例：

```c
#include <math.h>
#define EPSILON 1e-6

if (fabs(a - b) < EPSILON) {
    // a 和 b 足够接近，可以认为它们相等
}
```

### 6. **浮点数类型转换**

- **隐式转换**：在运算过程中，整数会自动转换为浮点数类型。例如，`int` 转换为 `float` 或 `double`。
- **显式转换**：使用强制类型转换进行转换，但会丢失精度。例如，将浮点数转换为整数，会丢失小数部分。

示例：

```c
float f = 3.14f;
int i = (int)f;  // 强制转换为整数，结果为 3
```

### 7. **浮点数常见函数**

- **`math.h`** 库中的函数常用于浮点数的数学运算：
    - `fabs(x)`：返回 `x` 的绝对值。
    - `fmod(x, y)`：返回 `x` 除以 `y` 的余数。
    - `pow(x, y)`：返回 `x` 的 `y` 次方。
    - `sqrt(x)`：返回 `x` 的平方根。
    - `sin(x)`, `cos(x)`, `tan(x)`：分别返回 `x` 的正弦、余弦和正切值（`x` 需要为弧度制）。
    - `log(x)`：返回 `x` 的自然对数。

示例：

```c
#include <math.h>

double x = 9.0;
double y = sqrt(x);  // y = 3.0
```

### 8. **浮点数的内存存储**

- 浮点数在内存中是以二进制形式存储的，有些小数在计算机中无法精确表示。
- **浮点数存储的精度限制**：例如，`0.1` 无法在二进制浮点数中精确表示，导致计算误差。

### 9. **浮点数输出**

- 在打印浮点数时，可以使用格式控制符来控制输出的精度：
    - `%f`：输出浮点数，默认显示 6 位小数。
    - `%.2f`：输出浮点数，保留 2 位小数。
    - `%e`：使用科学计数法输出浮点数。
    - `%g`：根据数值的大小，自动选择科学计数法或定点格式输出。

示例：

```c
float f = 3.1415926;
printf("%.2f\n", f);   // 输出：3.14
printf("%e\n", f);     // 输出：3.141593e+00
```

### 10. **浮点数的特殊值**

- 浮点数有几个特殊值，在 `<float.h>` 中定义：
    - **`INFINITY`**：正无穷大。
    - **`-INFINITY`**：负无穷大。
    - **`NaN`**：不是一个数字，通常由非法操作（如 `0/0`）产生。

示例：

```c
#include <math.h>

float inf = INFINITY; // 正无穷大
float nan_val = NAN;  // NaN
```

### 11. **浮点数与整数的混合运算**

- 在进行浮点数与整数的混合运算时，整数会自动转换为浮点数类型进行计算。
- 示例：
    
    ```c
    int i = 5;
    float f = 2.5;
    float result = i + f; // i 会自动转换为 float 类型
    ```
    

### 12. **浮点数的比较**

- 由于浮点数的精度限制，不能直接用 `==` 来比较两个浮点数是否相等。需要判断它们的差值是否在一个容忍的范围内。

示例：

```c
#define EPSILON 1e-6
if (fabs(a - b) < EPSILON) {
    // a 和 b 近似相等
}
```

### 13. **浮点数的舍入误差**

- 浮点数运算中经常会遇到舍入误差，尤其是在进行多次加法、乘法或者对大数字进行运算时。
- 为了减少误差，可以使用适当的误差范围来进行比较，并在计算中控制精度。

---
