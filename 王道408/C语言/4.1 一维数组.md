# 一. **定义与初始化**

一维数组的定义通常遵循以下语法：

```c
类型 名称[大小];
```

- **类型**：数组中存储数据的类型（如 `int`、`float`、`char` 等）。
- **名称**：数组的名称，用来引用数组。
- **大小**：数组中元素的个数，表示数组的长度。

**定义数组并初始化：**

```c
int arr[5] = {1, 2, 3, 4, 5};
```

如果初始化时提供的元素少于数组的大小，剩余的元素会被自动初始化为 0：

```c
int arr[5] = {1, 2};  // arr = {1, 2, 0, 0, 0}
```

# 二. **访问数组元素**

数组的每个元素都可以通过其索引来访问。索引从 0 开始，即第一个元素的索引是 0，第二个是 1，依此类推。

```c
int arr[5] = {10, 20, 30, 40, 50};
printf("%d\n", arr[0]);  // 输出 10
```

# 三. **数组的内存存储**

- 数组是 **连续** 存储在内存中的。每个元素占用相同大小的内存空间。
- 在 C 语言中，数组的内存分配是静态的，数组的大小在声明时就已确定，不能在运行时改变。
- 可以通过指针访问数组元素，因为数组名本身就是指向数组首元素的指针。

```c
int arr[3] = {1, 2, 3};
int *ptr = arr;
printf("%d\n", *(ptr + 1));  // 输出 2
```

# 四. **数组的边界问题**

数组访问时需要小心索引超出边界。如果访问越界，程序行为是未定义的，可能导致内存错误或崩溃。

```c
int arr[5] = {10, 20, 30, 40, 50};
printf("%d\n", arr[5]);  // 错误，越界访问
```

# 五. **数组作为函数参数**

在 C 语言中，数组传递给函数时，实际上是将数组的指针传递给函数。数组的大小并不会随之传递，因此如果需要知道数组的大小，需要显式传递。

```c
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printArray(arr, 5);
    return 0;
}
```

# 六. **数组和指针**

数组名本质上是指向数组首元素的指针。因此，数组和指针有很多相似之处，可以通过指针运算来遍历数组元素。

```c
int arr[3] = {1, 2, 3};
int *ptr = arr;
printf("%d\n", *(ptr + 2));  // 输出 3
```

# 七. **多维数组**

尽管一维数组是最常见的，但 C 语言也支持多维数组。多维数组可以看作是数组的数组，例如二维数组。

```c
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
printf("%d\n", arr[1][2]);  // 输出 6
```

# 八. **常见的数组操作**

## **遍历数组**：通过循环遍历数组中的每个元素。
    
    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    ```
    
## **求数组的最大值**：
    
    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    int max = arr[0];
    for (int i = 1; i < 5; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    printf("最大值是: %d\n", max);
    ```
    
## **反转数组**：

    ```c
    int arr[5] = {1, 2, 3, 4, 5};
    int temp;
    for (int i = 0; i < 2; i++) {
        temp = arr[i];
        arr[i] = arr[4 - i];
        arr[4 - i] = temp;
    }
    ```
------------------
# 九.数组访问越界

在 C 语言中，数组的索引是从 `0` 开始的，数组的大小在定义时是固定的。访问数组时，如果使用了超出数组边界的索引，就会发生**数组访问越界**的错误。这种越界访问不会引发编译错误，但会导致**未定义行为**，可能会覆盖其他内存数据、导致程序崩溃或产生不可预期的结果。

## 1. **数组越界的风险**

假设有以下数组定义：

```c
int arr[5] = {10, 20, 30, 40, 50};
```

- **合法访问：**
    
    ```c
    printf("%d\n", arr[0]);  // 输出 10
    printf("%d\n", arr[4]);  // 输出 50
    ```
    
- **越界访问：**
    
    ```c
    printf("%d\n", arr[5]);  // 错误，越界访问，访问未定义的内存
    ```
    

**注意**：`arr[5]` 访问的是数组之外的内存位置，虽然不会产生编译错误，但程序的行为是不可预测的。一般来说，越界访问可能会：

- **读取垃圾值**：如果越界访问只是读取数据，可能会读取到随机的内存值（例如未初始化的内存）。
- **覆盖数据**：如果越界访问写入数据，可能会修改其他变量或程序控制结构的值，导致程序崩溃或逻辑错误。

## 2. **如何避免数组越界**

- **明确数组大小**：定义数组时要确保索引不会超过数组的大小。
    
    ```c
    int arr[5];
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;  // 避免使用 arr[5] 之类的越界访问
    }
    ```
    
- **使用动态检查**：可以通过编写代码来检查索引值是否在合法范围内。
    
    ```c
    int index = 6;
    if (index >= 0 && index < 5) {
        printf("%d\n", arr[index]);
    } else {
        printf("索引越界！\n");
    }
    ```
    

# 十.数组作为函数参数

在 C 语言中，数组作为函数参数时，实际上是将数组的**指针**传递给函数，而不是将整个数组复制一份。函数接收到的是数组的**首地址**，因此对数组的修改会影响原数组。

## 1. **数组传递的方式**

数组名在 C 语言中代表数组首元素的地址，也就是说，传递数组时实际上是传递了一个指向数组首元素的指针。因此，在函数内部可以直接修改数组的内容。

## 2. **数组传递的代码示例**

- **传递数组及大小**：通常情况下，需要额外传递数组的大小，因为数组本身不包含大小信息。

```c
#include <stdio.h>

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printArray(arr, 5);  // 传递数组和大小
    return 0;
}
```

在此示例中，数组 `arr` 被传递到 `printArray` 函数中。由于传递的是数组的指针，因此在 `printArray` 函数内修改数组的值会影响原数组。

## 3. **通过指针传递数组**

你也可以显式地通过指针传递数组，这样可以明确地告诉函数数组的存储方式。

```c
#include <stdio.h>

void modifyArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = arr[i] * 2;  // 修改数组内容
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    modifyArray(arr, 5);  // 通过指针传递数组
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);  // 输出修改后的数组
    }
    return 0;
}
```

此示例中，`modifyArray` 函数通过指针修改传入数组的元素，最终 `arr` 数组会被修改为 `{2, 4, 6, 8, 10}`。

## 4. **数组的局限性**

- **无法获取数组大小**：C 语言中，当数组作为函数参数时，不能通过数组的名字获取数组的大小。这是因为数组作为函数参数时实际上传递的是指针，因此没有原数组的大小信息。为了避免错误，需要在函数调用时显式传递数组的大小。

```c
void printArray(int *arr, int size) {
    // 使用 size 确保遍历合法
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}
```

## 5. **常见问题**

- **数组大小未知时**：如果数组大小在编译时不确定，通常需要动态内存分配来处理数组的传递。
- **指针与数组的区别**：虽然数组名和指针在许多场合可以互换使用，但它们在 C 语言中的行为有所不同。例如，数组名不能被修改为指向其他内存位置，而指针是可以修改的。

## 6. **数组传递多维数组**

对于多维数组，在函数传递时，需要明确指定除了第一个维度外，其他维度的大小。

```c
void print2DArray(int arr[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
    print2DArray(arr, 2);  // 传递二维数组
    return 0;
}
```

在此示例中，二维数组的第二个维度（列数）在传递时需要明确指定为 `3`，否则编译器将无法正确处理数组。

---
