# 1. **逻辑运算符 (Logical Operators)**

逻辑运算符用于连接多个条件表达式，返回一个布尔值（`true` 或 `false`）。它们是程序中进行逻辑判断和控制流程的重要工具。

### 常见的逻辑运算符

| 运算符  | 描述                                   | 示例代码                   |
| ---- | ------------------------------------ | ---------------------- |
| `&&` | 逻辑与 (AND)：两个条件都为 `true` 时，结果为 `true` | `if (a > 5 && b < 10)` |
| \|\| | 逻辑或 (OR)：两个条件任一为 `true` 时，结果为 `true` | if (a < 3 \|\| b > 5)  |
| `!`  | 逻辑非 (NOT)：取反，若条件为 `true`，则返回 `false` | `if (!(a > 5))`        |

### 示例代码：

```cpp
int a = 5, b = 8;

// 逻辑与 (AND)：a > 5 并且 b < 10 时才为真
if (a > 3 && b < 10) {
    // 执行某些操作
}

// 逻辑或 (OR)：a > 5 或 b < 10 时为真
if (a < 3 || b > 5) {
    // 执行某些操作
}

// 逻辑非 (NOT)：条件取反
if (!(a > 5)) {
    // 执行某些操作
}
```

---

# 2. **赋值运算符 (Assignment Operators)**

赋值运算符用于将右侧的值赋给左侧的变量，赋值操作是编程中非常基础且重要的操作。

### 常见的赋值运算符

|运算符|描述|示例代码|
|---|---|---|
|`=`|赋值运算符：将右侧值赋给左侧变量|`a = 5;`|
|`+=`|加法赋值：`a += b` 相当于 `a = a + b`|`a += 3;`|
|`-=`|减法赋值：`a -= b` 相当于 `a = a - b`|`a -= 2;`|
|`*=`|乘法赋值：`a *= b` 相当于 `a = a * b`|`a *= 2;`|
|`/=`|除法赋值：`a /= b` 相当于 `a = a / b`|`a /= 4;`|
|`%=`|取余赋值：`a %= b` 相当于 `a = a % b`|`a %= 3;`|

### 示例代码：

```cpp
int a = 10;
a += 5;  // a = a + 5; 结果：a = 15
a -= 3;  // a = a - 3; 结果：a = 12
a *= 2;  // a = a * 2; 结果：a = 24
a /= 4;  // a = a / 4; 结果：a = 6
a %= 5;  // a = a % 5; 结果：a = 1
```

---

# 3. **求字节运算符 (Sizeof Operator)**

`sizeof` 是一个非常重要的运算符，用于返回数据类型或变量在内存中占用的字节数。它帮助程序员理解不同数据类型或对象的内存需求。

### 常见用法

|运算符|描述|示例代码|
|---|---|---|
|`sizeof`|获取数据类型或变量所占的字节数|`sizeof(int)` 或 `sizeof(a)`|

### 示例代码：

```cpp
int a = 10;
double b = 3.14;

// 获取类型的字节数
std::cout << "Size of int: " << sizeof(int) << " bytes" << std::endl;    // 输出 4
std::cout << "Size of double: " << sizeof(double) << " bytes" << std::endl; // 输出 8

// 获取变量的字节数
std::cout << "Size of a: " << sizeof(a) << " bytes" << std::endl;    // 输出 4
std::cout << "Size of b: " << sizeof(b) << " bytes" << std::endl;    // 输出 8
```

### 注意：

- `sizeof` 运算符在编译时计算，不会影响程序的运行时性能。
- 使用 `sizeof` 时，它会根据编译器的实现和系统的体系结构来计算字节数，因此不同平台上的结果可能不同。

---
# 4. 短路运算 (Short-circuit Evaluation)

**短路运算**是指在逻辑运算中，当运算符的结果已经可以确定时，程序会跳过对后续条件的计算，从而提高执行效率。这种技术主要应用于**逻辑与运算符 `&&`** 和 **逻辑或运算符 `||`** 中。

#### 1. **逻辑与运算符 `&&` (Logical AND)**

对于 `&&` 运算符，若左侧条件为 `false`，则无论右侧条件如何，整个表达式的结果都已经是 `false`，因此右侧条件不会被计算。

##### **短路规则**：

- **`A && B`**：如果 `A` 为 `false`，则 **不计算** `B`，结果为 `false`。

##### **示例：**

```cpp
int a = 0, b = 5;

if (a != 0 && b / a > 1) {
    // 由于 a != 0 为 false，右侧的 b / a > 1 不会被计算
    // 避免了除以零的错误
}
```

在上面的例子中，`a != 0` 为 `false`，所以 `b / a > 1` 不会被执行，从而避免了除以零错误。

---

#### 2. **逻辑或运算符 `||` (Logical OR)**

对于 `||` 运算符，若左侧条件为 `true`，则无论右侧条件如何，整个表达式的结果都已经是 `true`，因此右侧条件不会被计算。

##### **短路规则**：

- **`A || B`**：如果 `A` 为 `true`，则 **不计算** `B`，结果为 `true`。

##### **示例：**

```cpp
int a = 5, b = 0;

if (a != 0 || b / a > 1) {
    // 由于 a != 0 为 true，右侧的 b / a > 1 不会被计算
    // 避免了除以零的错误
}
```

在这个例子中，`a != 0` 为 `true`，所以 `b / a > 1` 不会被执行，从而避免了除以零的错误。

---

### **短路运算的实际应用**

短路运算最常见的一个用途是避免出现错误，比如除零错误、空指针引用等。可以通过在逻辑表达式中放置某些条件来保证后续条件的计算是安全的。

#### **示例：避免空指针引用**

假设我们在检查一个指针是否为空并访问它的成员时，可以利用短路运算来避免空指针访问。

```cpp
struct Person {
    int age;
};

Person* p = nullptr;

if (p != nullptr && p->age > 30) {
    // 只有 p != nullptr 为 true 时，p->age 才会被计算
    std::cout << "Age is greater than 30" << std::endl;
}
```

在这个例子中，`p != nullptr` 为 `false` 时，`p->age > 30` 就不会被执行，从而避免了空指针解引用的错误。

#### **示例：避免除以零错误**

通过逻辑运算符避免除零错误，尤其是在除法运算中。

```cpp
int a = 0, b = 5;

if (a != 0 && b / a > 1) {
    // a != 0 为 false，b / a > 1 不会被执行
    std::cout << "No division by zero" << std::endl;
}
```

---
# 5.三目运算符 (Ternary Operator)

三目运算符，也称为条件运算符，是 C 语言中一种简洁的条件判断方式。它是一种表达式，具有三个操作数，因此被称为 "三目" 运算符。

#### **基本语法**

```c
condition ? expression1 : expression2;
```

- **`condition`**：条件表达式。如果条件为真（非零），则执行 `expression1`，否则执行 `expression2`。
- **`expression1`**：条件为真时执行的表达式。
- **`expression2`**：条件为假时执行的表达式。

#### **示例 1：基本使用**

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20;

    int max = (a > b) ? a : b;
    printf("The maximum value is: %d\n", max);

    return 0;
}
```

**输出：**

```
The maximum value is: 20
```

**解释：**

- `(a > b)` 是条件表达式。
- 如果 `a > b` 为 `true`（即非零），则 `max = a`。
- 如果 `a > b` 为 `false`（即零），则 `max = b`。

---

#### **示例 2：使用三目运算符判断奇偶**

```c
#include <stdio.h>

int main() {
    int number = 5;
    
    printf("%d is %s\n", number, (number % 2 == 0) ? "even" : "odd");
    
    return 0;
}
```

**输出：**

```
5 is odd
```

**解释：**

- `(number % 2 == 0)` 是条件表达式，判断 `number` 是否为偶数。
- 如果为 `true`，则输出 "even"，否则输出 "odd"。

---

### **三目运算符的特点**

1. **简洁**：三目运算符使得代码更加简洁，尤其是在简单条件判断中。它可以用来代替 `if-else` 语句，避免冗长的代码。
    
2. **返回值**：三目运算符的返回值是表达式的结果，可以直接赋值给变量。它不仅仅是一个条件判断，而是返回其中一个表达式的值。
    
3. **可嵌套**：三目运算符可以嵌套使用，来处理多个条件判断，但应避免过度嵌套，以免影响代码的可读性。
    

#### **示例 3：嵌套三目运算符**

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20, c = 30;
    
    int max = (a > b) ? (a > c ? a : c) : (b > c ? b : c);
    printf("The maximum value is: %d\n", max);

    return 0;
}
```

**输出：**

```
The maximum value is: 30
```

**解释：**

- 首先判断 `a > b`，如果为 `true`，则判断 `a > c`；如果为 `false`，则判断 `b > c`。
- 嵌套使用三目运算符来判断最大值。

---

#### **示例 4：返回不同的类型**

三目运算符也可以根据条件选择不同类型的返回值。

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20;
    
    // 使用三目运算符选择不同类型的返回值
    float result = (a > b) ? 3.14f : 2.71f;
    printf("The result is: %.2f\n", result);

    return 0;
}
```

**输出：**

```
The result is: 2.71
```

**解释：**

- 根据条件 `a > b` 的结果，选择 `3.14f` 或 `2.71f` 作为返回值，并赋给 `result`。

---

### **注意事项**

4. **提高可读性**：虽然三目运算符可以使代码简洁，但过度使用嵌套的三目运算符可能会使代码的可读性降低，尤其是在逻辑较复杂时。此时，使用 `if-else` 语句会更加清晰。
    
5. **返回值类型一致性**：三目运算符的两个表达式必须具有相同的类型或可自动转换为相同类型。例如，`int` 类型和 `float` 类型不能直接混合，除非有类型转换。
    

--------------------------------
# 易错题
```C
5<3&&8<4-!0
```
