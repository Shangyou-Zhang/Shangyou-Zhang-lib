## 1. **整型数据类型概述**

### 1.1 **整型的分类**

C语言中的整型分为有符号整型和无符号整型，且每种整型有多种表示范围：

- **有符号整型（Signed Integer）**：可以存储正数、负数和零。
- **无符号整型（Unsigned Integer）**：只能存储正数和零。

C语言支持以下几种整型数据类型：

|数据类型|存储字节数|最小值|最大值|
|---|---|---|---|
|`char`|1 字节|-128 或 0|127 或 255|
|`short`|2 字节|-32,768|32,767|
|`int`|4 字节|-2,147,483,648|2,147,483,647|
|`long`|4 字节（或8字节）|-2,147,483,648 或 -9,223,372,036,854,775,808|2,147,483,647 或 18,446,744,073,709,551,615|
|`long long`|8 字节|-9,223,372,036,854,775,808|18,446,744,073,709,551,615|

### 1.2 **整型常量**

整型常量是指在程序中直接书写的整数值。它们的默认类型是 `int`。整型常量可分为十进制、八进制、十六进制三种形式。

- **十进制**：例如 `100`, `-200`。
- **八进制**：以 `0` 开头，例如 `075`。
- **十六进制**：以 `0x` 或 `0X` 开头，例如 `0xA3`, `0x7F`。

### 1.3 **整型范围**

不同类型的整型数据具有不同的表示范围，通常由数据类型的存储字节数决定。范围计算基于补码表示法，以下是常见整型的取值范围：

- `char` 类型通常是 1 字节，范围为 -128 到 127（有符号）或 0 到 255（无符号）。
- `short` 类型通常是 2 字节，范围为 -32,768 到 32,767（有符号）或 0 到 65,535（无符号）。
- `int` 类型通常是 4 字节，范围为 -2,147,483,648 到 2,147,483,647（有符号）或 0 到 4,294,967,295（无符号）。
- `long` 类型通常是 4 字节或 8 字节，具体范围与平台有关。
- `long long` 类型通常是 8 字节，范围为 -9,223,372,036,854,775,808 到 18,446,744,073,709,551,615（有符号）。

### 1.4 **整型类型转换**

在进行运算时，C语言会自动进行类型转换。特别是当不同类型的整型数参与运算时，`较小范围的类型会自动转换为较大范围的类型`，这称为“隐式类型转换”。例如，`char` 类型的数字会自动转换为 `int` 类型。

- **隐式转换**：如将 `short` 加到 `int` 时，`short` 会被自动提升为 `int`。
- **显式转换**：如将 `double` 强制转换为 `int`。

```c
int x = 10;
short y = 5;
int result = x + y;  // y 会被自动转换为 int 类型
```

### 1.5 **符号扩展与截断**

- **符号扩展**：当较小类型转换为较大类型时，符号位会被扩展，以保持符号一致。例如，`short` 转换为 `int` 时，负数的符号会被扩展到 `int` 中。
- **截断**：当较大类型转换为较小类型时，可能会丢失高位信息，导致数据截断。例如，`int` 转换为 `short` 时，可能会发生数据丢失。

---

## 2. **整型数据的存储规则**

### 2.1 **补码表示法**

在计算机中，整数通常采用 **补码** 形式进行存储和运算。补码是一种用于表示有符号整数的方法。补码有两个重要特点：

- **正数的补码**：与原码相同。
- **负数的补码**：对其绝对值的原码取反后加1。

#### 示例：

- **正数 5**：原码为 `0000 0101`，补码也为 `0000 0101`。
- **负数 -5**：原码为 `1000 0101`，补码为 `1111 1011`。

### 2.2 **溢出与溢出检测**

当运算结果超出整型类型的表示范围时，会发生溢出。溢出可能会导致程序错误，因此，理解溢出机制非常重要。

- **溢出检测**：如果两个操作数的符号相同，而结果符号与操作数符号不同，则发生溢出。

#### 示例：

```c
int a = INT_MAX;
int b = 1;
int result = a + b; // 发生溢出
```

### 2.3 **位域（Bit-field）**

位域允许在结构体中定义占用特定位数的整型成员。它常用于节省内存空间或与硬件寄存器进行映射。

#### 示例：

```c
struct {
    unsigned int flag1 : 1;
    unsigned int flag2 : 3;
    unsigned int value : 12;
} bitfield;
```

### 2.4 **内存对齐与填充**

在存储结构体时，C语言可能会根据数据类型的大小和内存对齐要求进行填充，即插入一些空白字节以满足对齐要求。

#### 示例：

```c
struct {
    char c;  // 1 字节
    int i;   // 4 字节
};
```

---

## 3. **位运算**

位运算是对整数类型的二进制位进行操作的运算，包括与（`&`）、或（`|`）、异或（`^`）、取反（`~`）、左移（`<<`）和右移（`>>`）。位运算常用于高效地处理标志位、权限控制、加密算法等场景。

### 3.1 **与运算（`&`）**

- **功能**：对两个操作数的每一位进行与运算，只有对应位都为 1 时，结果才为 1。

#### 示例：

```c
unsigned int flags = 0b1101;  // 二进制：1101
unsigned int mask = 0b1010;   // 二进制：1010
unsigned int result = flags & mask;  // 结果：1000
```

### 3.2 **或运算（`|`）**

- **功能**：对两个操作数的每一位进行或运算，只要对应位有一个为 1，结果就为 1。

#### 示例：

```c
unsigned int flags = 0b1101;  // 二进制：1101
unsigned int mask = 0b0010;   // 二进制：0010
unsigned int result = flags | mask;  // 结果：1111
```

### 3.3 **异或运算（`^`）**

- **功能**：对两个操作数的每一位进行异或运算，只有对应位不同，结果才为 1。

#### 示例：

```c
unsigned int flags = 0b1101;  // 二进制：1101
unsigned int mask = 0b1010;   // 二进制：1010
unsigned int result = flags ^ mask;  // 结果：0111
```

### 3.4 **取反运算（`~`）**

- **功能**：对操作数的每一位进行取反，0 变 1，1 变 0。

#### 示例：

```c
unsigned int flags = 0b1101;  // 二进制：1101
unsigned int result = ~flags;  // 结果：0010
```

### 3.5 **左移运算（`<<`）**

- **功能**：将操作数的二进制位向左移动指定的位数，右侧补零。

#### 示例：

```c
unsigned int value = 5;  // 二进制：0101
unsigned int result = value << 1;  // 结果：1010，即 10
```

### 3.6 **右移运算（`>>`）**

- **功能**：将操作数的二进制位向右移动指定的位数，左侧根据符号位补充。

#### 示例：

```c
unsigned int value = 5;  // 二进制：0101
unsigned int result = value >> 1;  // 结果：0010，即 2
```

---

## 4. **整型数据的常见应用**

### 4.1 **位标志（Bit Flags）**

使用整型变量的每一位作为标志位进行操作，位标志通常用于高效地表示状态、权限等，常见于操作系统和硬件控制。

#### 示例：

```c
unsigned int flags = 0;  // 所有标志位初始为 0
flags |= (1 << 2);       // 设置第 2 位为 1
flags &= ~(1 << 2);      // 清除第 2 位
```

---
